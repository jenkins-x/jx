package kube

import (
	"bytes"
	"encoding/json"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"html/template"
	"io/ioutil"
	"os"
	"path/filepath"
	"strconv"
	"strings"

	"github.com/jenkins-x/jx/pkg/gits"
	uuid "github.com/satori/go.uuid"

	"github.com/ghodss/yaml"

	"github.com/jenkins-x/jx/pkg/util"

	"github.com/jenkins-x/jx/pkg/log"

	"k8s.io/kube-openapi/pkg/builder"

	"k8s.io/kube-openapi/pkg/common"

	"github.com/go-openapi/spec"
	"github.com/pkg/errors"
)

const openapiTemplateSrc = `// +build !ignore_autogenerated

// Code generated by jx create client. DO NOT EDIT.
package openapi

import (
	openapicore "{{ $.Path }}"
	{{ range $i, $path := $.Dependents }}
	openapi{{ $i }} "{{ $path }}"
	{{ end }}
	"k8s.io/kube-openapi/pkg/common"
)

func GetOpenAPIDefinitions(ref common.ReferenceCallback) map[string]common.OpenAPIDefinition {
	result := make(map[string]common.OpenAPIDefinition)
    // This is our core openapi definitions (the ones for this module)
	for k, v := range openapicore.GetOpenAPIDefinitions(ref) {
		result[k] = v
	}
	// These are the ones we depend on
	{{ range $i, $path := $.Dependents }}
	for k, v := range openapi{{ $i}}.GetOpenAPIDefinitions(ref) {
		result[k] = v
	}
	{{ end }}
	return result
}

func GetNames(ref common.ReferenceCallback) []string {
	result := make([]string, 0)
	for k, _ := range openapicore.GetOpenAPIDefinitions(ref) {
		result = append(result, k)
	}
	return result
}
`

const schema_writerTemplateSrc = `package main

import (
	"flag"
	"os"
	"strings"

	openapi "{{ $.AllImportPath }}"

	"github.com/go-openapi/spec"

	"github.com/pkg/errors"

	"github.com/jenkins-x/jx/pkg/kube"
)

func main() {
	var outputDir, namesStr, title, version string
	flag.StringVar(&outputDir, "output-directory", "", "directory to write generated files to")
	flag.StringVar(&namesStr, "names", "", "comma separated list of resources to generate schema for, "+
		"if empty all resources will be generated")
	flag.StringVar(&title, "title", "", "title for OpenAPI and HTML generated docs")
	flag.StringVar(&version, "version", "", "version for OpenAPI and HTML generated docs")
	flag.Parse()
	if outputDir == "" {
		panic(errors.New("--output-directory cannot be empty"))
	}
	var names []string
	if namesStr != "" {
		names = strings.Split(namesStr, ",")
	} else {
		refCallback := func(path string) spec.Ref {
			return spec.Ref{}
		}
		names = openapi.GetNames(refCallback)
	}
	err := kube.WriteSchemaToDisk(outputDir, title, version, openapi.GetOpenAPIDefinitions, names)
	if err != nil {
		panic(errors.Wrapf(err, "writing schema to %s", outputDir))
	}
	os.Exit(0)
}
`

const (
	OpenApiDir              = "openapi"
	SchemaWriterSrcFileName = "schema_writer_generated.go"
	OpenApiV2JSON           = "openapiv2.json"
	OpenApiV2YAML           = "openapiv2.yaml"
	openApiGeneratorGitUrl  = "https://github.com/kubernetes/kube-openapi.git"
	apiDocsGeneratorGitUrl  = "https://github.com/kubernetes-incubator/reference-docs.git"
	codeGeneratorGitUrl     = "https://github.com/kubernetes/code-generator.git"
	bootstrapUrl            = "https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css"
	openApiGenerator        = "openapi-gen"
	apiDocsGenerator        = "apidocs-gen"
	apiDocsGeneratorDir     = "gen-apidocs"
	codeGenDir              = "codegen"
	bootstrapJsUrl          = "https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"
	bootstrapJsFileName     = "bootstrap-3.3.7.min.js"
	jqueryUrl               = "https://code.jquery.com/jquery-3.2.1.min.js"
	jqueryFileName          = "jquery-3.2.1.min.js"
	gengoPackage            = "k8s.io/gengo@v0.0.0-20190116091435-f8a0810f38af"
)

// AllGenerators is a list of all the generators provide by kubernetes code-generator
var AllGenerators = map[string]string{
	"defaulter": "defaulter-gen",
	"clientset": "client-gen",
	"listers":   "lister-gen",
	"informers": "informer-gen",
	"deepcopy":  "deepcopy-gen",
}

var fonts = []string{
	"FontAwesome.otf",
	"fontawesome-webfont.eot",
	"fontawesome-webfont.svg",
	"fontawesome-webfont.ttf",
	"fontawesome-webfont.woff",
	"fontawesome-webfont.woff2",
}

var css = []string{
	"stylesheet.css",
	"bootstrap.min.css",
	"font-awesome.min.css",
}

var js = []string{
	"jquery-3.2.1.min.js",
	"bootstrap-3.3.7.min.js",
}

var jsroot = []string{
	"scroll.js",
	"jquery.scrollTo.min.js",
}

var build = []string{
	"index.html",
	"navData.js",
}

type openapiTemplateData struct {
	Dependents []string
	Path       string
}

type schemaWriterTemplateData struct {
	AllImportPath string
}

// writeOpenApiAll code generates a file in openapi/all that reads in all the generated openapi structs and puts them
// in a single map, allowing them to be used by the schema writer and the CRD registration.
// baseDir is the root of the module, outputPackage is the base path of the output package,
// path is the path to the core openapi package (those that are generated for module the generator is run against),
// and dependents is the paths to the dependent openapi packages
func writeOpenApiAll(baseDir string, outputPackage string, path string, dependents []string) (string,
	error) {
	tmpl, err := template.New("openapi").Parse(openapiTemplateSrc)
	if err != nil {
		return "", errors.Wrapf(err, "parsing template for openapi_generated.go")
	}
	outputDir := filepath.Join(baseDir, outputPackage)
	err = os.MkdirAll(outputDir, 0700)
	if err != nil {
		return "", errors.Wrapf(err, "creating directory %s", outputDir)
	}
	outFilePath := filepath.Join(outputDir, "openapi_generated.go")
	outFile, err := os.Create(outFilePath)
	if err != nil {
		return "", errors.Wrapf(err, "creating file %s", outFilePath)
	}
	data := &openapiTemplateData{
		Path:       path,
		Dependents: dependents,
	}
	err = tmpl.Execute(outFile, data)
	defer func() {
		err := outFile.Close()
		if err != nil {
			log.Errorf("Error closing %s %v\n", outFilePath, err)
		}
	}()
	if err != nil {
		return "", errors.Wrapf(err, "templating %s", outFilePath)
	}
	return outputPackage, nil
}

// writeSchemaWriterToDisk code generates a simple main function that can be called to write the contents of all the
// OpenAPI structs out to JSON and YAML. It's implemented like this to allow us to automatically call the schema
// writer without requiring the user to write a command themselves. baseDir is the path to the module,
// outputPackage is the path to the outputPacakge for the code generator,
// and allImportPath is the path to the package where the generated map of all the structs is
func writeSchemaWriterToDisk(baseDir string, outputPackage string, allImportPath string) (string, error) {
	tmpl, err := template.New("schema_writer").Parse(schema_writerTemplateSrc)
	if err != nil {
		return "", errors.Wrapf(err, "parsing template for %s", SchemaWriterSrcFileName)
	}
	outputDir := filepath.Join(baseDir, outputPackage)
	err = os.MkdirAll(outputDir, 0700)
	if err != nil {
		return "", errors.Wrapf(err, "creating directory %s", outputDir)
	}
	outFilePath := filepath.Join(outputDir, SchemaWriterSrcFileName)
	outFile, err := os.Create(outFilePath)
	if err != nil {
		return "", errors.Wrapf(err, "creating file %s", outFilePath)
	}
	data := &schemaWriterTemplateData{
		AllImportPath: allImportPath,
	}
	err = tmpl.Execute(outFile, data)
	defer func() {
		err := outFile.Close()
		if err != nil {
			log.Errorf("Error closing %s %v\n", outFilePath, err)
		}
	}()
	if err != nil {
		return "", errors.Wrapf(err, "templating %s", outFilePath)
	}
	return outputPackage, nil
}

// WriteSchemaToDisk is called by the code generated main function to marshal the contents of the OpenAPI structs and
// write them to disk. outputDir is the dir to write the json and yaml files to,
// you can also provide the title and version for the OpenAPI spec.
// definitions is the function that returns all the openapi definitions.
// WriteSchemaToDisk will rewrite the definitions to a dot-separated notation, reversing the initial domain name
func WriteSchemaToDisk(outputDir string, title string, version string, definitions common.GetOpenAPIDefinitions,
	names []string) error {
	err := os.MkdirAll(outputDir, 0700)
	if err != nil {
		return errors.Wrapf(err, "creating --output-directory %s", outputDir)
	}
	config := common.Config{
		Info: &spec.Info{
			InfoProps: spec.InfoProps{
				Version: version,
				Title:   title,
			},
		},
		GetDefinitions: definitions,
		GetDefinitionName: func(name string) (string, spec.Extensions) {
			// For example "github.com/jenkins-x/jx/pkg/apis/jenkins.io/v1.AppSpec"
			parts := strings.Split(name, "/")
			if len(parts) < 3 {
				// Can't do anything with it, return raw
				return name, nil
			}
			var result []string
			for i, part := range parts {
				// handle the domain at the start of the package
				if i == 0 {
					subparts := strings.Split(part, ".")
					for j := len(subparts) - 1; j >= 0; j-- {
						result = append(result, subparts[j])
					}
				} else if i < len(parts)-1 {
					// The docs generator can't handle a dot in the group name, so we remove it
					result = append(result, strings.Replace(part, ".", "_", -1))
				} else {
					result = append(result, part)
				}
			}
			return strings.Join(result, "."), nil
		},
	}

	spec, err := builder.BuildOpenAPIDefinitionsForResources(&config, names...)
	if err != nil {
		return errors.Wrapf(err, "building openapi definitions for %s", names)
	}
	bytes, err := json.Marshal(spec)
	if err != nil {
		return errors.Wrapf(err, "marshaling openapi definitions to json for %s", names)
	}
	outFile := filepath.Join(outputDir, OpenApiV2JSON)
	err = ioutil.WriteFile(outFile, bytes, 0644)
	if err != nil {
		return errors.Wrapf(err, "writing openapi definitions for %s to %s", names, outFile)
	}
	return nil
}

func packageToDirName(pkg string) string {
	str := strings.Join(strings.Split(pkg, "/"), "_")
	str = strings.Join(strings.Split(str, "."), "_")
	return str
}

// GetBoilerplateFile is responsible for canonicalizing the name of the boilerplate file
func GetBoilerplateFile(fileName string, verbose bool) (string, error) {
	if fileName != "" {
		if _, err := os.Stat(fileName); err != nil && !os.IsNotExist(err) {
			return "", errors.Wrapf(err, "error reading boilerplate file %s", fileName)
		} else if err == nil {
			abs, err := filepath.Abs(fileName)
			if err == nil {
				fileName = abs
			}
			if verbose {
				log.Errorf("error converting %s to absolute path so leaving as is %v", fileName, err)
			}
		}
	}
	return fileName, nil
}

// GenerateSchema calls the generated schema writer and then loads the output and also writes out a yaml version. The
// outputDir is the base directory for writing the schemas to (they get put in the openapi-spec subdir),
// inputPackage is the packge in which generated code lives, inputBase is the path to the module,
// title and version are used in the OpenAPI spec files.
func GenerateSchema(outputDir string, inputPackage string, inputBase string, title string, version string) error {
	schemaWriterSrc := filepath.Join(inputPackage, OpenApiDir, SchemaWriterSrcFileName)
	schemaWriterBinary, err := ioutil.TempFile("", "")
	outputDir = filepath.Join(outputDir, "openapi-spec")
	defer func() {
		err := util.DeleteFile(schemaWriterBinary.Name())
		if err != nil {
			log.Warnf("Error cleaning up tempfile %s created to compile %s to %v",
				schemaWriterBinary.Name(), SchemaWriterSrcFileName, err)
		}
	}()
	if err != nil {
		return errors.Wrapf(err, "creating tempfile to compile %s to %v", SchemaWriterSrcFileName, err)
	}
	cmd := util.Command{
		Dir:  inputBase,
		Name: "go",
		Args: []string{
			"build",
			"-o",
			schemaWriterBinary.Name(),
			schemaWriterSrc,
		},
	}
	out, err := cmd.RunWithoutRetry()
	if err != nil {
		return errors.Wrapf(err, "running %s, output %s", cmd.String(), out)
	}
	fileJSON := filepath.Join(outputDir, OpenApiV2JSON)
	fileYAML := filepath.Join(outputDir, OpenApiV2YAML)
	cmd = util.Command{
		Name: schemaWriterBinary.Name(),
		Args: []string{
			"--output-directory",
			outputDir,
			"--title",
			title,
			"--version",
			version,
		},
	}
	out, err = cmd.RunWithoutRetry()
	if err != nil {
		return errors.Wrapf(err, "running %s, output %s", cmd.String(), out)
	}
	// Convert to YAML as well
	bytes, err := ioutil.ReadFile(fileJSON)
	if err != nil {
		return errors.Wrapf(err, "reading %s", fileJSON)
	}
	yamlBytes, err := yaml.JSONToYAML(bytes)
	if err != nil {
		return errors.Wrapf(err, "converting %s to yaml", fileJSON)
	}
	err = ioutil.WriteFile(fileYAML, yamlBytes, 0644)
	if err != nil {
		return errors.Wrapf(err, "writing %s", fileYAML)
	}
	return nil
}

// InstallGenApiDocs installs the gen-apidocs tool from the kubernetes-incubator/reference-docs repository.
// It takes a version (really a commit-ish) and the gitter client
func InstallGenApiDocs(version string, gitter gits.Gitter) (string, error) {
	binDir, err := util.JXBinLocation()
	if err != nil {
		return "", errors.Wrapf(err, "getting ~/.jx/bin")
	}
	log.Infof("Installing %s %s to %s\n", apiDocsGeneratorGitUrl, version, binDir)
	dir, err := cloneOrFetch(apiDocsGeneratorGitUrl, version, gitter)
	if err != nil {
		return "", err
	}
	// reference-docs has no dependency managemnt, but it will work with modules
	modInitCmd := util.Command{
		Dir:  dir,
		Name: "go",
		Args: []string{
			"mod",
			"init",
		},
	}
	out, err := modInitCmd.RunWithoutRetry()
	if err != nil {
		return "", errors.Wrapf(err, "running %s, output %s", modInitCmd.String(), out)
	}

	installCmd := util.Command{
		Dir:  dir,
		Name: "go",
		Args: []string{
			"build",
			"-o",
			filepath.Join(binDir, apiDocsGenerator),
			fmt.Sprintf("%s/main.go", apiDocsGeneratorDir),
		},
	}
	out, err = installCmd.RunWithoutRetry()
	if err != nil {
		return "", errors.Wrapf(err, "running %s, output %s", installCmd.String(), out)
	}
	return dir, nil
}

// AssembleApiDocsStatic copies the static files from the referenceDocsRepo to the outputDir.
// It also downloads from CDN jquery and bootstrap js
func AssembleApiDocsStatic(referenceDocsRepo string, outputDir string) error {
	srcDir := filepath.Join(referenceDocsRepo, "gen-apidocs", "generators", "static")
	outDir := filepath.Join(outputDir, "static")
	log.Infof("Copying static files from %s to %s\n", srcDir, outDir)
	err := util.CopyDirPreserve(srcDir, outDir)
	if err != nil {
		return errors.Wrapf(err, "copying %s to %s", srcDir, outDir)
	}
	err = util.DownloadFile(filepath.Join(outDir, bootstrapJsFileName), bootstrapJsUrl)
	if err != nil {
		return err
	}
	err = util.DownloadFile(filepath.Join(outDir, jqueryFileName), jqueryUrl)
	if err != nil {
		return err
	}
	return nil
}

// GenerateApiDocs runs the apidocs-gen tool against configDirectory which includes the openapi-spec dir,
// the config.yaml file, static content and the static_includes
func GenerateApiDocs(configDir string, verbose bool) error {
	// Clean
	includesDir := filepath.Join(configDir, "includes")
	err := util.DeleteDirContents(includesDir)
	if err != nil {
		return errors.Wrapf(err, "deleting contents of %s", includesDir)
	}
	buildDir := filepath.Join(configDir, "build")
	err = util.DeleteDirContents(buildDir)
	if err != nil {
		return errors.Wrapf(err, "deleting contents of %s", buildDir)
	}
	binDir, err := util.JXBinLocation()
	if err != nil {
		return errors.Wrapf(err, "getting ~/.jx/bin")
	}
	codegenRootDir, _, err := getCodeGenDirRoot()
	if err != nil {
		return errors.Wrapf(err, "getting codegen dir")
	}
	cmd := util.Command{
		Dir:  configDir,
		Name: filepath.Join(binDir, "apidocs-gen"),
		Args: []string{
			"--config-dir",
			configDir,
			"--munge-groups",
			"false",
		},
		Env: map[string]string{
			"GOPATH": codegenRootDir,
		},
	}
	out, err := cmd.RunWithoutRetry()
	if err != nil {
		return errors.Wrapf(err, "running %s, output %s", cmd.String(), out)
	}
	if verbose {
		log.Infof("Running %s\n", cmd.String())
		log.Infoln(out)
	}
	return nil
}

// AssembleApiDocs copies the generated html files and the static files from srcDir into outputDir
func AssembleApiDocs(srcDir string, outputDir string) error {
	// Clean the dir
	err := util.DeleteDirContents(outputDir)
	if err != nil {
		return errors.Wrapf(err, "deleting contents of %s", outputDir)
	}
	// Copy the fonts over
	err = copyStaticFiles(filepath.Join(srcDir, "static"), filepath.Join(outputDir, "fonts"), fonts)
	if err != nil {
		return err
	}
	// Copy the css over
	err = copyStaticFiles(filepath.Join(srcDir, "static"), filepath.Join(outputDir, "css"), css)
	if err != nil {
		return err
	}
	// Copy the static jsroot over
	err = copyStaticFiles(filepath.Join(srcDir, "static"), filepath.Join(outputDir, ""), jsroot)
	if err != nil {
		return err
	}

	// Copy the static js over
	err = copyStaticFiles(filepath.Join(srcDir, "static"), filepath.Join(outputDir, "js"), js)
	if err != nil {
		return err
	}
	// Copy the generated files over
	err = copyStaticFiles(filepath.Join(srcDir, "build"), filepath.Join(outputDir, ""), build)
	if err != nil {
		return err
	}
	return nil
}

func copyStaticFiles(srcDir string, outputDir string, resources []string) error {
	err := os.MkdirAll(outputDir, 0700)
	if err != nil {
		return errors.Wrapf(err, "making %s", outputDir)
	}
	for _, resource := range resources {
		srcPath := filepath.Join(srcDir, resource)
		dstPath := filepath.Join(outputDir, resource)
		err := util.CopyFile(srcPath, dstPath)
		if err != nil {
			return errors.Wrapf(err, "copying %s to %s", srcPath, dstPath)
		}
	}
	return nil
}

//InstallOpenApiGen installs the openapi-gen tool from kubernetes/kube-openapi using the gitter client. A version (
// really commit-ish) is specified.
func InstallOpenApiGen(version string, gitter gits.Gitter) error {
	binDir, err := util.JXBinLocation()
	if err != nil {
		return errors.Wrapf(err, "getting ~/.jx/bin")
	}
	log.Infof("Installing %s %s to %s\n", openApiGeneratorGitUrl, version, binDir)
	dir, err := cloneOrFetch(openApiGeneratorGitUrl, version, gitter)
	if err != nil {
		return err
	}

	if exists, err := util.FileExists(filepath.Join(dir, "go.mod")); !exists || err != nil {
		// kube-openapi is using Godeps which is ancient, but it will work with modules - tbh the standalone build of this
		// looks a bit abandoned
		modInitCmd := util.Command{
			Dir:  dir,
			Name: "go",
			Args: []string{
				"mod",
				"init",
			},
		}
		out, err := modInitCmd.RunWithoutRetry()
		if err != nil {
			return errors.Wrapf(err, "running %s, output %s", modInitCmd.String(), out)
		}
		// the version of gengo that modules tries to load is too old for the actual code
		goGetCmd := util.Command{
			Dir:  dir,
			Name: "go",
			Args: []string{
				"get",
				gengoPackage,
			},
		}
		out, err = goGetCmd.RunWithoutRetry()
		if err != nil {
			return errors.Wrapf(err, "running %s, output %s", goGetCmd.String(), out)
		}
	}

	installCmd := util.Command{
		Dir:  dir,
		Name: "go",
		Args: []string{
			"build",
			"-o",
			filepath.Join(binDir, openApiGenerator),
			fmt.Sprintf("./cmd/%s/%s.go", openApiGenerator, openApiGenerator),
		},
	}
	out, err := installCmd.RunWithoutRetry()
	if err != nil {
		return errors.Wrapf(err, "running %s, output %s", installCmd.String(), out)
	}
	return nil
}

//InstallGen installs a number of generator tools from kubernetes/code-generator using the gitter client. A version (
// really commit-ish) is specified.
func InstallGen(version string, gitter gits.Gitter) error {

	binDir, err := util.JXBinLocation()
	if err != nil {
		return errors.Wrapf(err, "getting ~/.jx/bin")
	}
	log.Infof("Installing %s %s to %s\n", codeGeneratorGitUrl, version, binDir)
	dir, err := cloneOrFetch(codeGeneratorGitUrl, version, gitter)
	if err != nil {
		return err
	}
	codegenRootDir, _, err := getCodeGenDirRoot()
	if err != nil {
		return errors.Wrapf(err, "getting codegen dir")
	}

	for _, generator := range AllGenerators {
		if generator != "" {
			installCmd := util.Command{
				Dir:  dir,
				Name: "go",
				Args: []string{
					"build",
					"-o",
					filepath.Join(binDir, generator),
					fmt.Sprintf("./cmd/%s", generator),
				},
				Env: map[string]string{
					"GOPATH": codegenRootDir,
				},
			}
			out, err := installCmd.RunWithoutRetry()
			if err != nil {
				return errors.Wrapf(err, "running %s, output %s", installCmd.String(), out)
			}
		}
	}
	return nil
}

func cloneOrFetch(gitUrl string, commitish string, gitter gits.Gitter) (string, error) {
	repo, err := gits.ParseGitURL(gitUrl)
	if err != nil {
		return "", errors.Wrapf(err, "parsing %s", gitUrl)
	}
	dir, err := getCodeGenDir(filepath.Join(repo.Host, repo.Organisation, repo.Name))
	if err != nil {
		return "", err
	}
	empty, err := util.IsEmpty(dir)
	if err != nil {
		return "", errors.Wrapf(err, "checking %s is empty", dir)
	}
	if empty {
		err := gitter.Clone(gitUrl, dir)
		if err != nil {
			return "", errors.Wrapf(err, "cloning %s to %s", gitUrl, dir)
		}
	} else {
		err := gitter.FetchBranch(dir, "origin", "")
		if err != nil {
			return "", errors.Wrapf(err, "fetching origin from %s", gitUrl)
		}
	}
	branchName := uuid.NewV4().String()
	if commitish == "" {
		commitish = "master"
	}
	err = gitter.CreateBranchFrom(dir, branchName, commitish)
	if err != nil {
		return "", errors.Wrapf(err, "creating branch with start-point %s", commitish)
	}

	err = gitter.Checkout(dir, branchName)
	if err != nil {
		return "", errors.Wrapf(err, "checking out branch with start-point %s", commitish)
	}
	return dir, nil
}

func getCodeGenDir(subPath string) (string, error) {
	_, srcDir, err := getCodeGenDirRoot()
	if err != nil {
		return "", err
	}
	dir := filepath.Join(srcDir, subPath)
	err = os.MkdirAll(dir, 0700)
	if err != nil {
		return "", errors.Wrapf(err, "creating %s/%s", srcDir, openApiGeneratorGitUrl)
	}
	return dir, nil
}

func getCodeGenDirRoot() (string, string, error) {
	jxDir, err := util.ConfigDir()
	if err != nil {
		return "", "", errors.Wrapf(err, "creating ~/.jx")
	}
	baseDir := filepath.Join(jxDir, codeGenDir)
	dir := filepath.Join(baseDir, "src")
	err = os.MkdirAll(dir, 0700)
	if err != nil {
		return "", "", errors.Wrapf(err, "creating ~/.jx/%s/src", codeGenDir)
	}
	return baseDir, dir, nil
}

func getOutputPackageForOpenApi(pkg string, groupWithVersion []string, outputPackage string) (string, error) {
	if len(groupWithVersion) != 2 {
		return "", errors.Errorf("groupWithVersion must be of length 2 but is %s", groupWithVersion)
	}
	version := groupWithVersion[1]
	if version == "" {
		version = "unversioned"
	}
	return filepath.Join(outputPackage, "openapi", fmt.Sprintf("%s_%s_%s", packageToDirName(pkg),
		groupWithVersion[0],
		version)), nil
}

// GenerateOpenApi generateds the OpenAPI structs and schema files.
// It looks at the specified groupsWithVersions in inputPackage and generates to outputPackage (
// relative to the module outputBase). Any openApiDependencies also have OpenAPI structs generated.
// A boilerplateFile is written to the top of any generated files.
// The gitter client is used to ensure the correct versions of dependencies are loaded.
func GenerateOpenApi(groupsWithVersions []string, inputPackage string, outputPackage string, relativePackage string,
	outputBase string, openApiDependencies []string, moduleDir string, moduleName string, gitter gits.Gitter,
	boilerplateFile string,
	verbose bool) error {
	basePkg := fmt.Sprintf("%s/openapi", outputPackage)
	corePkg := fmt.Sprintf("%s/core", basePkg)
	allPkg := fmt.Sprintf("%s/all", basePkg)
	// Generate the dependent openapi structs as these are missing from the k8s client
	dependentPackages, err := generateOpenApiDependenciesStruct(outputPackage, relativePackage, outputBase,
		openApiDependencies,
		moduleDir, moduleName, gitter, verbose, boilerplateFile)
	if err != nil {
		return err
	}
	// Generate the main openapi struct
	err = defaultGenerate(openApiGenerator, "openapi", groupsWithVersions, inputPackage,
		corePkg, outputBase, boilerplateFile, verbose, "--output-package", corePkg)
	if err != nil {
		return err
	}
	_, err = writeOpenApiAll(outputBase, allPkg, corePkg, dependentPackages)
	if err != nil {
		return err
	}
	_, err = writeSchemaWriterToDisk(outputBase, basePkg, allPkg)
	if err != nil {
		return err
	}
	return nil
}

// GenerateClient runs the generators specified. It looks at the specified groupsWithVersions in inputPackage and generates to outputPackage (
//// relative to the module outputBase). A boilerplateFile is written to the top of any generated files.
func GenerateClient(generators []string, groupsWithVersions []string, inputPackage string, outputPackage string,
	outputBase string, boilerplateFile string, verbose bool) error {
	for _, generatorName := range generators {
		if generator, ok := AllGenerators[generatorName]; ok {
			switch generatorName {
			case "clientset":
				err := generateWithOutputPackage(generator,
					generatorName,
					groupsWithVersions,
					inputPackage,
					outputPackage,
					outputBase,
					boilerplateFile,
					verbose,
					"--clientset-name",
					"versioned")
				if err != nil {
					return err
				}
			case "deepcopy":
				err := defaultGenerate(generator,
					generatorName,
					groupsWithVersions,
					inputPackage,
					outputPackage,
					outputBase,
					boilerplateFile,
					verbose,
					"-O",
					"zz_generated.deepcopy",
					"--bounding-dirs",
					inputPackage)
				if err != nil {
					return err
				}
			case "informers":
				err := generateWithOutputPackage(generator,
					generatorName,
					groupsWithVersions,
					inputPackage,
					outputPackage,
					outputBase,
					boilerplateFile,
					verbose,
					"--versioned-clientset-package",
					fmt.Sprintf("%s/clientset/versioned", outputPackage),
					"--listers-package",
					fmt.Sprintf("%s/listers", outputPackage))
				if err != nil {
					return err
				}
			default:
				err := generateWithOutputPackage(generator, generatorName, groupsWithVersions, inputPackage,
					outputPackage, outputBase, boilerplateFile, verbose)
				if err != nil {
					return err
				}
			}
		} else {
			return errors.Errorf("no generator %s available", generatorName)
		}
	}
	return nil
}

func generateWithOutputPackage(generator string, name string, groupsWithVersions []string,
	inputPackage string, outputPackage string, outputBase string, boilerplateFile string,
	verbose bool, args ...string) error {
	args = append(args, "--output-package", fmt.Sprintf("%s/%s", outputPackage, name))
	return defaultGenerate(generator, name, groupsWithVersions, inputPackage, outputPackage, outputBase,
		boilerplateFile, verbose, args...)
}

func defaultGenerate(generator string, name string, groupsWithVersions []string, inputPackage string,
	outputPackage string, outputBase string, boilerplateFile string,
	verbose bool, args ...string) error {
	log.Infof("Generating %s structs for %s at %s\n", name, groupsWithVersions, outputPackage)

	binDir, err := util.JXBinLocation()
	if err != nil {
		return errors.Wrapf(err, "getting ~/.jx/bin")
	}
	generateCommand := util.Command{
		Name: filepath.Join(binDir, generator),
		Args: []string{
			"--output-base",
			outputBase,
			"--go-header-file",
			boilerplateFile,
		},
	}
	if name == "clientset" {
		inputDirs := make([]string, 0)
		for _, gv := range groupsWithVersions {
			groupVersion := strings.Split(gv, ":")
			if len(groupVersion) != 2 {
				return errors.Errorf("argument %s must be like cheese:v1", gv)
			}
			inputDirs = append(inputDirs, fmt.Sprintf("%s/%s", groupVersion[0], groupVersion[1]))
		}
		inputDirsStr := strings.Join(inputDirs, ",")
		generateCommand.Args = append(generateCommand.Args, "--input", inputDirsStr, "--input-base", inputPackage)
	} else {
		inputDirs := make([]string, 0)
		for _, gv := range groupsWithVersions {
			groupVersion := strings.Split(gv, ":")
			if len(groupVersion) != 2 {
				return errors.Errorf("argument %s must be like cheese:v1", gv)
			}
			inputDirs = append(inputDirs, fmt.Sprintf("%s/%s/%s", inputPackage, groupVersion[0], groupVersion[1]))
		}
		inputDirsStr := strings.Join(inputDirs, ",")
		generateCommand.Args = append(generateCommand.Args, "--input-dirs", inputDirsStr)
	}
	for _, arg := range args {
		generateCommand.Args = append(generateCommand.Args, arg)
	}
	if verbose {
		log.Infof("Running %s\n", generateCommand.String())
	}
	out, err := generateCommand.RunWithoutRetry()
	if err != nil {
		return errors.Wrapf(err, "running %s, output %s", generateCommand.String(), out)
	}
	return nil
}

func generateOpenApiDependenciesStruct(outputPackage string, relativePackage string, outputBase string,
	openApiDependencies []string,
	moduleDir string, moduleName string, gitter gits.Gitter, verbose bool, boilerplateFile string) ([]string, error) {
	paths := make([]string, 0)
	modulesRequirements, err := util.GetModuleRequirements(moduleDir)
	if err != nil {
		return nil, errors.Wrapf(err, "getting module requirements for %s", moduleDir)
	}
	for _, d := range openApiDependencies {
		// First, make sure we have the right files in our .jx GOPATH
		// Use go mod to find out the dependencyVersion for our main tree
		ds := strings.Split(d, ":")
		if len(ds) != 4 {
			return nil, errors.Errorf("--open-api-dependency %s must be of the format path:package:group"+
				":apiVersion", d)
		}
		path := ds[0]
		pkg := ds[1]
		group := ds[2]
		version := ds[3]
		groupsWithVersions := []string{
			fmt.Sprintf("%s:%s", group, version),
		}

		dependencyVersion := "master"
		if moduleRequirement, ok := modulesRequirements[moduleName]; !ok {
			log.Warnf("Unable to find module requirement for %s, please add it to your go.mod, "+
				"for now using HEAD of the master branch", moduleName)
		} else {
			if requirementVersion, ok := moduleRequirement[path]; !ok {
				log.Warnf("Unable to find module requirement version for %s (module %s), "+
					"please add it to your go.mod, "+
					"for now using HEAD of the master branch", pkg, moduleName)
			} else {
				dependencyVersion = requirementVersion
			}
		}

		if strings.HasPrefix(dependencyVersion, "v0.0.0-") {
			parts := strings.Split(dependencyVersion, "-")
			if len(parts) != 3 {
				return nil, errors.Errorf("unable to parse dependencyVersion %s", dependencyVersion)
			}
			// this is the sha
			dependencyVersion = parts[2]
		}
		codeGenDir, srcDir, err := getCodeGenDirRoot()
		if err != nil {
			return nil, err
		}
		// Use go get to download it
		cmd := util.Command{
			Name: "go",
			Args: []string{
				"get",
				"-d",
				fmt.Sprintf("%s/...", path),
			},
			Env: map[string]string{
				"GO111MODULE": "off",
				"GOPATH":      codeGenDir,
			},
		}
		out, err := cmd.RunWithoutRetry()
		if err != nil {
			return nil, errors.Wrapf(err, "running %s, output %s", cmd.String(), out)
		}

		parts := []string{
			srcDir,
		}
		parts = append(parts, strings.Split(path, "/")...)
		dir := filepath.Join(parts...)
		log.Infof("Adding OpenAPI dependency %s to %s\n", d, dir)
		branchName := uuid.NewV4().String()
		err = gitter.CreateBranchFrom(dir, branchName, dependencyVersion)
		if err != nil {
			return nil, errors.Wrapf(err, "creating branch from %s", dependencyVersion)
		}
		err = gitter.Checkout(dir, branchName)
		if err != nil {
			return nil, errors.Wrapf(err, "checking out branch from %s", branchName)
		}
		// Now we can run the generator against it
		generator := openApiGenerator
		outputPackage, err := getOutputPackageForOpenApi(path, []string{group, version}, outputPackage)
		if err != nil {
			return nil, errors.Wrapf(err, "getting filename for openapi structs for %s", d)
		}
		err = defaultGenerate(generator,
			"openapi",
			groupsWithVersions,
			filepath.Join(path, pkg),
			outputPackage,
			outputBase,
			boilerplateFile,
			verbose,
			"--output-package",
			outputPackage)
		if err != nil {
			return nil, err
		}
		relativeOutputPackage, err := getOutputPackageForOpenApi(path, []string{group, version}, relativePackage)
		if err != nil {
			return nil, errors.Wrapf(err, "getting filename for openapi structs for %s", d)
		}
		// the generator forgets to add the spec import in some cases
		generatedFile := filepath.Join(relativeOutputPackage, "openapi_generated.go")
		fs := token.NewFileSet()
		f, err := parser.ParseFile(fs, generatedFile, nil, parser.ParseComments)
		if err != nil {
			return nil, errors.Wrapf(err, "parsing %s", generatedFile)
		}
		found := false
		for _, imp := range f.Imports {
			if strings.Trim(imp.Path.Value, "\"") == "github.com/go-openapi/spec" {
				found = true
				break
			}
		}
		if !found {
			// Add the imports
			for i := 0; i < len(f.Decls); i++ {
				d := f.Decls[i]

				switch d.(type) {
				case *ast.FuncDecl:
					// No action
				case *ast.GenDecl:
					dd := d.(*ast.GenDecl)

					// IMPORT Declarations
					if dd.Tok == token.IMPORT {
						// Add the new import
						iSpec := &ast.ImportSpec{Path: &ast.BasicLit{Value: strconv.Quote("github.com/go-openapi/spec")}}
						dd.Specs = append(dd.Specs, iSpec)
					}
				}
			}

			// Sort the imports
			ast.SortImports(fs, f)
			var buf bytes.Buffer
			err = format.Node(&buf, fs, f)
			if err != nil {
				errors.Wrapf(err, "convert AST to []byte for %s", generatedFile)
			}
			// Manually add new lines after build tags
			lines := strings.Split(string(buf.Bytes()), "\n")
			buf.Reset()
			for _, line := range lines {
				buf.WriteString(line)
				buf.WriteString("\r\n")
				if strings.HasPrefix(line, "// +") {
					buf.WriteString("\r\n")
				}
			}

			err = ioutil.WriteFile(generatedFile, buf.Bytes(), 0644)
			if err != nil {
				errors.Wrapf(err, "writing %s", generatedFile)
			}
		}
		paths = append(paths, outputPackage)
	}
	return paths, nil
}
